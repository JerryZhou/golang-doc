# Regular Expression Matching Can Be Simple And Fast

## Introduction
关于正则表达式有这么一个小段子，有两个方法来实现正则匹配。其中一种是被广泛使用的，许多的编程语言都是用的这种，几乎是一种标准的实现，包括我们见到的Perl、Python等；另外一种只是在少数几个不太起眼的地方用到，比如Unix下的工具awk和grep。两个方法的性能数据差别很大，如下图所示：
![a?a?a?aaa](https://swtch.com/~rsc/regexp/grep3p.png)![image](https://swtch.com/~rsc/regexp/grep4p.png)
```math
 a?^3a^3 == a?a?a?aaa
 ```
 前面出现的a?-n-a-n-我们来简化一下表达式，比如a?-3-a-3-就是a?a?a?aaa的简写，上面的测试案例就是用上述的重复式样来匹配a-n-这样的原字符串。

 我们可以注意到在测试数据差异非常大，Perl匹配长度为29的字符串就已经需要超过60秒，而另外一种叫做Thomposon-NFA的方法只需要20毫秒。而且图里面我们看到对于NFA对应的方法它的时间抽的单位是毫秒，而且对于长度越长的正则串，他们之间的差异就越大，对于100个字符的船,Thompson只需要200毫秒，而Perl采用的方法却需要10-15-年(其实Perl只是一种比较典型的语言，其他常见的Python、PHP或者Ruby等都是类似的状况)。

 前面的图表看起来非常难以置信：或许你也有使用过Perl，而且也没有觉得它的正则表达式有性能问题。事实上，大部分时间，Perl的正则匹配效率还是很高的，只是确实我们可以很容易写出一种对Perl可以称为“病态”的正则串，但是对Thompson-NFA来说确是一个非常正常的串。需要这个时候你可以心里已经产生了一个疑问：为什么Perl不采用Thompson-NFA的这种实现方式呢？他确实可以，而且应该采用这种方式，这篇文章下面的内容就会详细的讲解NFA的具体实现算法。

 历史上，正则表达式是计算机科学中一个非常的理论和工程结合的例子。正则表达式是理论学家发明的一个非常简单的计算模型，Ken Thompson把他带到了工业界，带给了广大的程序员，他在给CTSS实现文本编辑器QED的时候实现了正则表达式。后面Dennis Ritchie跟随脚步，在给GE-TSS写文本编辑器GED的时候也干了这个事情。 后面Thompson和Ritchie一起去倒腾Unix的时候也一并把正则表达带进来了。在70年代后期，正则表达式在Unix上也形成了一道亮丽的独特风景，许多的工具应运而生，包括ed、grep、awk和lex等。

 今天，正则表达式也成为了一个非常经典的例子，我们看到在脱离理论后，在工业界，在广大的程序员手上被整得不成样子。今天我们流行的这些使用正则表达式的工具，他的运行效率比30年的Unix工具效率已经低到不能忍的地步了。

 这篇文章我们会来回顾老头子Thomposon在1960年代中期发明的关于正则表达式，有限状态机，正则匹配搜索算法等理论知识。同时我们也会在这篇文章中把相关理论的实现做描述。其实整个实现还不到400行C代码，但它其实比Perl里面的那种实现不知道要优秀了多少代的。同时他的实现复杂度还比那些被用在Perl、Python、PCRE等还要低。这边文章会讨论理论，同时也会把理论怎么到具体的实现做讨论和阐述。

## Reglular Expressions

正则表达式其实是一个助记符，他描述的就是一组字符串。如果给定的字符串出现在正则表达式描述的字符串组里面，我们就说这个正则表达式匹配当前字符串。

一个最简单的正则表达式就是一个单独的字符，当前我们这里要去掉如下的一些元字符`*+?()|`，如果要匹配这些元字符，我们需要在元字符前面加一个反斜杠：比如`\+`匹配加号字符。

可以通过两个正则规则：可选和连接来组成新的正则表达式。如果`e1`匹配`s`以及`e2`匹配`t`，那么`e1|e2`可以匹配`s`或者`t`；`e1e2`匹配`st`。

元字符 `*`、`+`和`?`都是属于重复操作符：`e*`匹配零个或者多个字符串(字符串可以不一样)，其中每一个字符串都匹配规则`e`；`e+`匹配一个或者多个；`e?`匹配零个或者一个。

操作符的处理优先级是 或操作 < 连接操作 < 重复操作。一个明确的括号符可以用来强制表达不同的意思，和算术运算里面一样，比如：`ab|cd`和`(ab)|(cd)`是等价的；`ab*`和`a(b*)`是等价的。

到现在为止，我们描述的正则表达式是传统的Unix的egrep正则表达式语法的一个子集。现在描述的这个子集已经足够来描绘正则语言：简单说，正则语言就是一组字符串，在一个固定的内存消耗下，这组字符串我们可以通过一个pass就可以来对目标串进行匹配。现在新的正则表达式(比较典型的是Perl里面的正则表达式)都是在这个基础上，新增一些新的操作符合一些编码串。新增的这些正则表达式规则会让正则语言编写更简单，但有的时候这些新增的规则也把这个搞复杂但其实并没有达到更强大的效果了。而且新增的那些看起来很漂亮的表达式通常都还不如用传统的语法来表达。

一个给正则表达式提供额外能力的典型的正则扩展就是`backreferences`后向引用。后向引用的意思就是用`\1`或者`\2`这样的表达式来匹配前面已经匹配过的具体字符串。比如`(cat|dog)\1`可以匹配`catcat`或者`dogdog`，但不能匹配`catdog`或者`dogcat`.严格意义上来说`backreferences`不是正则表达式，而且支持的`backreferences`需要消耗巨大的代价，比如典型的在Perl里面，在某些条件下这个搜索算法是指数复杂度的。而且现在Perl等语言已经不能移除对`backreferences`的支持了。当然这些语言可以改进相关实现，对于没有出现`backreferences`的正则表达式采用一些其他的算法。

## Finite Automata

另外一个用来描述一组字符串的方法就是有限状态机。在后面想文章中，我们会交替使用`automaton`和`machine`来表达这个。

下面一个简单的例子，我们来看下和正则表达式`a(bb)+a`匹配同样的一组字符串的这么一个状态机：

![image](https://swtch.com/~rsc/regexp/fig0.png)

一个有限状态机他任何时候都会处于它其中的某一个状态(前面图中的一个圆圈就是一个状态，圈圈里面的标签我们文章的后面再说明)。这个状态机从字符串一个一个读取字符的时候，他会从一个状态到另外一个状态进行迁移。状态机有两个特殊的状态：一个起始状态`s0`和匹配状态`s4`。起始状态会有一个缺少来源线的箭头指向它，而匹配状态会被画成两个圈的形式。

状态机从字符串一个字符一个字符的读取，输入字符串上的箭头标示当前的读取字符，状态机上状态间的连接箭头上的字符标示的是状态间转移的条件字符。键入输入字符串是`abbbba`。状态机读取的第一个字符是`a`，这个时候状态机处于`s0`，读取`a`后跳转到`s1`。状态机在一次从输入串读取其他字符重复这个过程：依次读`b`跳转到`s2`，读`b`跳转到`s3`，读`b`跳转到`s2`，读`b`跳转到`s3`，最后读`a`跳转到`s4`。

![image](https://swtch.com/~rsc/regexp/fig1.png)

状态机最后停留在`s4`的匹配状态，这个时候就叫做状态机匹配字符串`abbbba`。如果状态机最后停留的状态不是`s4`，那么状态机就不匹配这个字符串。如果在状态机执行的过程中，读取一个字符后，发现没有相应的状态可以跳转，这个时候状态机就会过早的停下来。

我们前面描述的状态机，我们叫做DFA(deterministic finite automaton)确定优先状态机，在任何状态下，每一个可能的字符输入都会有至多有一个新的跳转状态。我们也可以创建一种装机，他在某些情况下需要多个可选的跳转状态下做选择。比如下面的张太极他就不是确定的：

![image](https://swtch.com/~rsc/regexp/fig2.png)

这个状态机就不是确定的，因为当他处于`s2`的状态的时候，如果读取`b`后，下一个跳转状态有多个选择，他可以跳转到`s1`也可以跳转到`s3`。因为状态机对后续的输入这个时候还是未知的，他没有足够的信息来做正确与否的决定，这个时候到底跳转到那个状态才是正确的是一个非常有意思的事情。对于这种状态机，我们叫非确定性状态机NFAS后者NDFAS。对于NFAS来说，如果存在一条路径匹配字符串，我们就叫这个NFA匹配这个字符串。

有的时候，如果允许NFA里面出现一种零输入的跳转是一个非常遍历的方法。我们对于不需要输入的跳转，我们在图上他们的跳转箭头上就不写任何输入标示。一个NFA如果处于存在无标示跳转的状态，他可以选择不读取任何数据而执行相应的无标示跳转。下面图中的状态机与前面的状态机等价，但他更清晰的表达了正则表达式`a(bb)+a`：

![image](https://swtch.com/~rsc/regexp/fig3.png)

## Converting Regular Expressions to NFAs

可以证明在能力上正则表达式和NFAs他们是等值的：每一个正则表达式都有一个NFA(他们匹配同样的字符串组)匹配。(其实也可以证明DFAs在能力上与NFAs以及正则表达式也是一致的，这个我们在文章的后面会看到)。有多种方法可以把正则表达式转换到NFAs。本文描述的方法由Thompson在1968年发表在CACM的论文上。

一个正则表达式的NFA是通过组合一组对应到正则表达式的子表达式匹配的NFAs构造的。正则表达式里面的每一个操作符都有一种他自己的组合方式。每一个子表达式对应的NFAs本身是不具备匹配状态的(子表达式对应的状态机是没有终结状态的)，反而他们会有一些指向未知状态的箭头，整个构造过程会把这些链接起来构造一个完整的匹配状态。

匹配单独一个字符的NFAs看起来是这样的：

![image](https://swtch.com/~rsc/regexp/fig4.png)

链接操作符`e1e2`的NFA看起来是这样的，`e1`的结束箭头指向`e2`的开始：

![image](https://swtch.com/~rsc/regexp/fig5.png)

可选操作符`e1|e2`会增加一个起始状态来做选择：

![image](https://swtch.com/~rsc/regexp/fig6.png)

重复操作符`e?`的状态机会增加一个空的路径：

![image](https://swtch.com/~rsc/regexp/fig7.png)

重复操作符`e*`和前面的类似，只是增加一个循环路径：

![image](https://swtch.com/~rsc/regexp/fig8.png)

重复操作符`e+`也会创建一个循环路径，只是他会要求这儿循环路径至少执行一次：

![image](https://swtch.com/~rsc/regexp/fig9.png)

前面的图我们可以看出，我们会为每一个字符包括每一个元字符会创建一个相应的状态。因此最后NFA的状态数基本会和正则表达式一样。

通过前面的NFA例子，我们知道任何时候都可以移除哪些没有标示的状态跳转箭头，我们也可以完全不依赖这种无标示跳转，只是加上这种跳转会更清晰的表达正则表达式，而且更加容易理解，而且让后面的C语言实现也更加简单，所以我们保留这种无标示跳转。

## Regular Expression Search Algorithms



